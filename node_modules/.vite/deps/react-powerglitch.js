import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-powerglitch/lib/react-powerglitch.es.js
var import_react = __toESM(require_react());
var w = {};
(function(l) {
  Object.defineProperty(l, "__esModule", { value: true }), l.PowerGlitch = l.mergeOptions = void 0;
  const d = (t = "always") => ({
    playMode: t,
    createContainers: true,
    hideOverflow: false,
    timing: t === "always" ? { duration: 2 * 1e3, iterations: 1 / 0 } : { duration: 250, iterations: 1 },
    glitchTimeSpan: t === "always" ? { start: 0.5, end: 0.7 } : { start: 0, end: 1 },
    shake: {
      velocity: 15,
      amplitudeX: 0.2,
      amplitudeY: 0.2
    },
    slice: t === "click" ? {
      count: 15,
      velocity: 20,
      minHeight: 0.02,
      maxHeight: 0.15,
      hueRotate: true
    } : {
      count: 6,
      velocity: 15,
      minHeight: 0.02,
      maxHeight: 0.15,
      hueRotate: true
    },
    pulse: false
  }), f = (t, a) => {
    if (!t.glitchTimeSpan)
      return 1;
    const e = t.glitchTimeSpan.start, n = t.glitchTimeSpan.end;
    if (a < e || a > n)
      return 0;
    const i = e + (n - e) / 2;
    return a < i ? (a - e) / (i - e) : (n - a) / (n - i);
  }, u = (t, a) => (Math.random() - 0.5) * 2 * f(t, a), p = ({ minHeight: t, maxHeight: a, minWidth: e, maxWidth: n }) => {
    const i = Math.floor(Math.random() * ((a - t) * 100 + 1)) + t * 100, c = Math.floor(Math.random() * ((n - e) * 100 + 1)) + e * 100, r = Math.floor(Math.random() * (100 - i)), s = Math.floor(Math.random() * (100 - c)), m = `${s + c}% ${r}%`, o = `${s + c}% ${r + i}%`, h = `${s}% ${r + i}%`, E = `${s}% ${r}%`;
    return `polygon(${m},${o},${h},${E})`;
  }, v = (t) => {
    const a = Math.floor(t.slice.velocity * t.timing.duration / 1e3) + 1, e = [];
    for (let n = 0; n < a; ++n) {
      if (f(t, n / a) === 0) {
        e.push({
          opacity: "0",
          transform: "none",
          clipPath: "unset"
        });
        continue;
      }
      const c = {
        opacity: "1",
        transform: `translate3d(${u(t, n / a) * 30}%,0,0)`,
        clipPath: p({ minHeight: t.slice.minHeight, maxHeight: t.slice.maxHeight, minWidth: 1, maxWidth: 1 })
      };
      t.slice.hueRotate && (c.filter = `hue-rotate(${Math.floor(u(t, n / a) * 360)}deg)`), e.push(c);
    }
    return {
      steps: e,
      timing: Object.assign({ easing: `steps(${a},jump-start)` }, t.timing)
    };
  }, G = (t) => t.pulse ? {
    steps: [
      { transform: "scale(1)", opacity: "1" },
      { transform: `scale(${t.pulse.scale})`, opacity: "0" }
    ],
    timing: Object.assign(Object.assign({}, t.timing), { delay: (t.glitchTimeSpan ? t.glitchTimeSpan.start : 0) * t.timing.duration, easing: "ease-in-out" })
  } : null, C = (t) => {
    if (!t.shake)
      return { steps: [], timing: {} };
    const a = Math.floor(t.shake.velocity * t.timing.duration / 1e3) + 1, e = [];
    for (let n = 0; n < a; ++n) {
      const i = u(t, n / a) * t.shake.amplitudeX * 100, c = u(t, n / a) * t.shake.amplitudeY * 100;
      e.push({
        transform: `translate3d(${i}%,${c}%,0)`
      });
    }
    return {
      steps: e,
      timing: Object.assign({ easing: `steps(${a},jump-start)` }, t.timing)
    };
  }, g = (t) => [
    C(t),
    G(t),
    ...Array.from({ length: t.slice.count }).map(() => v(t))
  ].filter((a) => a !== null), y = (...t) => {
    const a = (e) => e && typeof e == "object";
    return t.reduce((e, n) => (Object.keys(n).forEach((i) => {
      a(e[i]) && a(n[i]) ? e[i] = (0, l.mergeOptions)(e[i], n[i]) : n[i] !== void 0 && (e[i] = n[i]);
    }), e), {});
  };
  l.mergeOptions = y;
  const M = (t, a) => {
    var e, n;
    if (!a.createContainers)
      return {
        container: t,
        layersContainer: t,
        glitched: t.firstElementChild
      };
    if (!t.dataset.glitched) {
      const r = document.createElement("div"), s = document.createElement("div");
      return getComputedStyle(t).getPropertyValue("display").match(/^inline/) && (s.style.display = "inline-block"), s.appendChild(r), (e = t.parentElement) === null || e === void 0 || e.insertBefore(s, t), r.prepend(t), {
        container: s,
        layersContainer: r,
        glitched: t
      };
    }
    const i = t.parentElement, c = (n = t.parentElement) === null || n === void 0 ? void 0 : n.parentElement;
    for (; i.children.length > 1; )
      i.removeChild(i.children[1]);
    return i.firstElementChild.getAnimations().forEach((r) => r.cancel()), {
      container: c,
      layersContainer: i,
      glitched: t
    };
  }, b = (t, a, e) => {
    const { glitched: n, container: i, layersContainer: c } = M(t, e);
    c.style.display = "grid", e.hideOverflow && (i.style.overflow = "hidden"), e.html && (n.innerHTML = e.html), n.style.gridArea = "1/1/-1/-1";
    const r = n.cloneNode(true);
    r.style.gridArea = "1/1/-1/-1", r.style.userSelect = "none", r.style.pointerEvents = "none", r.style.opacity = "0";
    for (let o = 0; o < a.length - 1; ++o) {
      const h = r.cloneNode(true);
      c.appendChild(h);
    }
    const s = () => {
      a.forEach((o, h) => {
        c.children[h].animate(o.steps, o.timing);
      });
    }, m = () => {
      a.forEach((o, h) => {
        c.children[h].getAnimations().forEach((E) => {
          E.cancel();
        });
      });
    };
    switch (i.onmouseenter = null, i.onmouseleave = null, i.onclick = null, e.playMode) {
      case "always":
        s();
        break;
      case "hover":
        i.onmouseenter = s, i.onmouseleave = m;
        break;
      case "click":
        i.onclick = () => {
          m(), s();
        };
        break;
    }
    return t.dataset.glitched = "1", { container: i, startGlitch: s, stopGlitch: m };
  }, A = (t = ".powerglitch", a = {}) => {
    const e = (0, l.mergeOptions)(d(a.playMode), a);
    let n = [];
    typeof t == "string" ? n = Array.from(document.querySelectorAll(t)) : t instanceof NodeList ? n = Array.from(t) : Array.isArray(t) ? n = t : t instanceof HTMLElement && (n = [t]);
    const i = g(e), c = n.map((r) => b(r, i, e));
    return {
      containers: c.map((r) => r.container),
      startGlitch: () => c.forEach((r) => r.startGlitch()),
      stopGlitch: () => c.forEach((r) => r.stopGlitch())
    };
  };
  l.PowerGlitch = {
    glitch: A,
    generateLayers: g,
    getDefaultOptions: d
  };
})(w);
function H(l) {
  const [d, f] = (0, import_react.useState)(l), [u, p] = (0, import_react.useState)(() => () => {
  }), [v, G] = (0, import_react.useState)(() => () => {
  });
  return {
    ref: (0, import_react.useCallback)((g) => {
      if (!g)
        return;
      const y = w.PowerGlitch.glitch(g, d);
      p(() => y.startGlitch), G(() => y.stopGlitch);
    }, [d]),
    startGlitch: u,
    stopGlitch: v,
    setOptions: f
  };
}
export {
  H as useGlitch
};
//# sourceMappingURL=react-powerglitch.js.map
